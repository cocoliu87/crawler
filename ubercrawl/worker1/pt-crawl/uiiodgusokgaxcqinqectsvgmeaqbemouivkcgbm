uiiodgusokgaxcqinqectsvgmeaqbemouivkcgbm length 6 144457 page 10127 Algebraization of first-order logic In mathematical logic, predicate functor logic (PFL) is one of several ways to express first-order logic (also known as predicate logic) by purely algebraic means, i.e., without quantified variables. PFL employs a small number of algebraic devices called predicate functors (or predicate modifiers)[1] that operate on terms to yield terms. PFL is mostly the invention of the logician and philosopher Willard Quine. Motivation[edit] The source for this section, as well as for much of this entry, is Quine (1976). Quine proposed PFL as a way of algebraizing first-order logic in a manner analogous to how Boolean algebra algebraizes propositional logic. He designed PFL to have exactly the expressive power of first-order logic with identity. Hence the metamathematics of PFL are exactly those of first-order logic with no interpreted predicate letters: both logics are sound, complete, and undecidable. Most work Quine published on logic and mathematics in the last 30 years of his life touched on PFL in some way.[citation needed] Quine took "functor" from the writings of his friend Rudolf Carnap, the first to employ it in philosophy and mathematical logic, and defined it as follows: "The word functor, grammatical in import but logical in habitat... is a sign that attaches to one or more expressions of given grammatical kind(s) to produce an expression of a given grammatical kind." (Quine 1982: 129) Ways other than PFL to algebraize first-order logic include: Cylindric algebra by Alfred Tarski and his American students. The simplified cylindric algebra proposed in Bernays (1959) led Quine to write the paper containing the first use of the phrase "predicate functor"; The polyadic algebra of Paul Halmos. By virtue of its economical primitives and axioms, this algebra most resembles PFL; Relation algebra algebraizes the fragment of first-order logic consisting of formulas having no atomic formula lying in the scope of more than three quantifiers. That fragment suffices, however, for Peano arithmetic and the axiomatic set theory ZFC; hence relation algebra, unlike PFL, is incompletable. Most work on relation algebra since about 1920 has been by Tarski and his American students. The power of relation algebra did not become manifest until the monograph Tarski and Givant (1987), published after the three important papers bearing on PFL, namely Bacon (1985), Kuhn (1983), and Quine (1976); Combinatory logic builds on combinators, higher order functions whose domain is another combinator or function, and whose range is yet another combinator. Hence combinatory logic goes beyond first-order logic by having the expressive power of set theory, which makes combinatory logic vulnerable to paradoxes. A predicate functor, on the other hand, simply maps predicates (also called terms) into predicates. PFL is arguably the simplest of these formalisms, yet also the one about which the least has been written. Quine had a lifelong fascination with combinatory logic, attested to by his introduction to the translation in Van Heijenoort (1967) of the paper by the Russian logician Moses Schönfinkel founding combinatory logic. When Quine began working on PFL in earnest, in 1959, combinatory logic was commonly deemed a failure for the following reasons: Until Dana Scott began writing on the model theory of combinatory logic in the late 1960s, almost only Haskell Curry, his students, and Robert Feys in Belgium worked on that logic; Satisfactory axiomatic formulations of combinatory logic were slow in coming. In the 1930s, some formulations of combinatory logic were found to be inconsistent. Curry also discovered the Curry paradox, peculiar to combinatory logic; The lambda calculus, with the same expressive power as combinatory logic, was seen as a superior formalism. Kuhn's formalization[edit] The PFL syntax, primitives, and axioms described in this section are largely Steven Kuhn's (1983). The semantics of the functors are Quine's (1982). The rest of this entry incorporates some terminology from Bacon (1985). Syntax[edit] An atomic term is an upper case Latin letter, I and S excepted, followed by a numerical superscript called its degree, or by concatenated lower case variables, collectively known as an argument list. The degree of a term conveys the same information as the number of variables following a predicate letter. An atomic term of degree 0 denotes a Boolean variable or a truth value. The degree of I is invariably 2 and so is not indicated. The "combinatory" (the word is Quine's) predicate functors, all monadic and peculiar to PFL, are Inv, inv, ∃, +, and p. A term is either an atomic term, or constructed by the following recursive rule. If τ is a term, then Invτ, invτ, ∃τ, +τ, and pτ are terms. A functor with a superscript n, n a natural number > 1, denotes n consecutive applications (iterations) of that functor. A formula is either a term or defined by the recursive rule: if α and β are formulas, then αβ and ~(α) are likewise formulas. Hence "~" is another monadic functor, and concatenation is the sole dyadic predicate functor. Quine called these functors "alethic." The natural interpretation of "~" is negation; that of concatenation is any connective that, when combined with negation, forms a functionally complete set of connectives. Quine's preferred functionally complete set was conjunction and negation. Thus concatenated terms are taken as conjoined. The notation + is Bacon's (1985); all other notation is Quine's (1976; 1982). The alethic part of PFL is identical to the Boolean term schemata of Quine (1982). As is well known, the two alethic functors could be replaced by a single dyadic functor with the following syntax and semantics: if α and β are formulas, then (αβ) is a formula whose semantics are "not (α and/or β)" (see NAND and NOR). Axioms and semantics[edit] Quine set out neither axiomatization nor proof procedure for PFL. The following axiomatization of PFL, one of two proposed in Kuhn (1983), is concise and easy to describe, but makes extensive use of free variables and so does not do full justice to the spirit of PFL. Kuhn gives another axiomatization dispensing with free variables, but that is harder to describe and that makes extensive use of defined functors. Kuhn proved both of his PFL axiomatizations sound and complete. This section is built around the primitive predicate functors and a few defined ones. The alethic functors can be axiomatized by any set of axioms for sentential logic whose primitives are negation and one of ∧ or ∨. Equivalently, all tautologies of sentential logic can be taken as axioms. Quine's (1982) semantics for each predicate functor are stated below in terms of abstraction (set builder notation), followed by either the relevant axiom from Kuhn (1983), or a definition from Quine (1976). The notation { x 1 ⋯ x n : F x 1 ⋯ x n } {\displaystyle \{x_{1}\cdots x_{n}:Fx_{1}\cdots x_{n}\}} denotes the set of n-tuples satisfying the atomic formula F x 1 ⋯ x n . {\displaystyle Fx_{1}\cdots x_{n}.} Identity, I, is defined as: I F x 1 x 2 ⋯ x n ↔ ( F x 1 x 1 ⋯ x n ↔ F x 2 x 2 ⋯ x n ) . {\displaystyle IFx_{1}x_{2}\cdots x_{n}\leftrightarrow (Fx_{1}x_{1}\cdots x_{n}\leftrightarrow Fx_{2}x_{2}\cdots x_{n}){\text{.}}} Identity is reflexive (Ixx), symmetric (Ixy→Iyx), transitive ((Ixy∧Iyz) → Ixz), and obeys the substitution property: ( F x 1 ⋯ x n ∧ I x 1 y ) → F y x 2 ⋯ x n . {\displaystyle (Fx_{1}\cdots x_{n}\land Ix_{1}y)\rightarrow Fyx_{2}\cdots x_{n}.} Padding, +, adds a variable to the left of any argument list. + F n = d e f { x 0 x 1 ⋯ x n : F n x 1 ⋯ x n } . {\displaystyle \ +F^{n}\ {\overset {\underset {\mathrm {def} }{}}{=}}\ \{x_{0}x_{1}\cdots x_{n}:F^{n}x_{1}\cdots x_{n}\}.} + F x 1 ⋯ x n ↔ F x 2 ⋯ x n . {\displaystyle +Fx_{1}\cdots x_{n}\leftrightarrow Fx_{2}\cdots x_{n}.} Cropping, ∃, erases the leftmost variable in any argument list. ∃ F n = d e f { x 2 ⋯ x n : ∃ x 1 F n x 1 ⋯ x n } . {\displaystyle \exists F^{n}\ {\overset {\underset {\mathrm {def} }{}}{=}}\ \{x_{2}\cdots x_{n}:\exists x_{1}F^{n}x_{1}\cdots x_{n}\}.} F x 1 ⋯ x n → ∃ F x 2 ⋯ x n . {\displaystyle Fx_{1}\cdots x_{n}\rightarrow \exists Fx_{2}\cdots x_{n}.} Cropping enables two useful defined functors: Reflection, S: S F n = d e f { x 2 ⋯ x n : F n x 2 x 2 ⋯ x n } . {\displaystyle SF^{n}\ {\overset {\underset {\mathrm {def} }{}}{=}}\ \{x_{2}\cdots x_{n}:F^{n}x_{2}x_{2}\cdots x_{n}\}.} S F n ↔ ∃ I F n . {\displaystyle SF^{n}\leftrightarrow \exists IF^{n}.} S generalizes the notion of reflexivity to all terms of any finite degree greater than 2. N.B: S should not be confused with the primitive combinator S of combinatory logic. Cartesian product, × {\displaystyle \times } ; F m × G n ↔ F m ∃ m G n . {\displaystyle F^{m}\times G^{n}\leftrightarrow F^{m}\exists ^{m}G^{n}.} Here only, Quine adopted an infix notation, because this infix notation for Cartesian product is very well established in mathematics. Cartesian product allows restating conjunction as follows: F m x 1 ⋯ x m G n x 1 ⋯ x n ↔ ( F m × G n ) x 1 ⋯ x m x 1 ⋯ x n . {\displaystyle F^{m}x_{1}\cdots x_{m}G^{n}x_{1}\cdots x_{n}\leftrightarrow (F^{m}\times G^{n})x_{1}\cdots x_{m}x_{1}\cdots x_{n}.} Reorder the concatenated argument list so as to shift a pair of duplicate variables to the far left, then invoke S to eliminate the duplication. Repeating this as many times as required results in an argument list of length max(m,n). The next three functors enable reordering argument lists at will. Major inversion, Inv, rotates the variables in an argument list to the right, so that the last variable becomes the first. Inv ⁡ F n = d e f { x 1 ⋯ x n : F n x n x 1 ⋯ x n − 1 } . {\displaystyle \operatorname {Inv} F^{n}\ {\overset {\underset {\mathrm {def} }{}}{=}}\ \{x_{1}\cdots x_{n}:F^{n}x_{n}x_{1}\cdots x_{n-1}\}.} Inv ⁡ F x 1 ⋯ x n ↔ F x n x 1 ⋯ x n − 1 . {\displaystyle \operatorname {Inv} Fx_{1}\cdots x_{n}\leftrightarrow Fx_{n}x_{1}\cdots x_{n-1}.} M contentType 24 text/html; charset=UTF-8 url 57 https://en.wikipedia.org:443/wiki/Predicate_functor_logic responseCode 3 200 