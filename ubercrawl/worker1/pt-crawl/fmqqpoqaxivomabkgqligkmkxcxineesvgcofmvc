fmqqpoqaxivomabkgqligkmkxcxineesvgcofmvc length 6 174075 page 10100 Algorithm for the minimization of Boolean functions Hasse diagram of the search graph of the algorithm for 3 variables. Given e.g. the subset S = { a b c , a b ¯ c , a ¯ b c , a ¯ b c ¯ , a ¯ b ¯ c } {\displaystyle S=\{abc,a{\overline {b}}c,{\overline {a}}bc,{\overline {a}}b{\overline {c}},{\overline {a}}{\overline {b}}c\}} of the bottom-level nodes (light green), the algorithm computes a minimal set of nodes (here: { a ¯ b , c } {\displaystyle \{{\overline {a}}b,c\}} , dark green) that covers exactly S {\displaystyle S} . The Quine–McCluskey algorithm (QMC), also known as the method of prime implicants, is a method used for minimization of Boolean functions that was developed by Willard V. Quine in 1952[1][2] and extended by Edward J. McCluskey in 1956.[3] As a general principle this approach had already been demonstrated by the logician Hugh McColl in 1878,[4][5][6] was proved by Archie Blake in 1937,[7][8][9][6] and was rediscovered by Edward W. Samson and Burton E. Mills in 1954[10][6] and by Raymond J. Nelson in 1955.[11][6] Also in 1955, Paul W. Abrahams and John G. Nordahl[12] as well as Albert A. Mullin and Wayne G. Kellner[13][14][15][16] proposed a decimal variant of the method.[17][14][15][16][18][19][20][21] The Quine–McCluskey algorithm is functionally identical to Karnaugh mapping, but the tabular form makes it more efficient for use in computer algorithms, and it also gives a deterministic way to check that the minimal form of a Boolean function has been reached. It is sometimes referred to as the tabulation method. The method involves two steps: Finding all prime implicants of the function. Use those prime implicants in a prime implicant chart to find the essential prime implicants of the function, as well as other prime implicants that are necessary to cover the function. Complexity[edit] Although more practical than Karnaugh mapping when dealing with more than four variables, the Quine–McCluskey algorithm also has a limited range of use since the problem it solves is NP-complete.[22][23][24] The running time of the Quine–McCluskey algorithm grows exponentially with the number of variables. For a function of n variables the number of prime implicants can be as large as 3 n / n {\displaystyle 3^{n}/{\sqrt {n}}} ,[25] e.g. for 32 variables there may be over 534 × 1012 prime implicants. Functions with a large number of variables have to be minimized with potentially non-optimal heuristic methods, of which the Espresso heuristic logic minimizer was the de facto standard in 1995.[needs update][26] Step two of the algorithm amounts to solving the set cover problem;[27] NP-hard instances of this problem may occur in this algorithm step.[28][29] Example[edit] Input[edit] In this example, the input is a Boolean function in four variables, f : { 0 , 1 } 4 → { 0 , 1 } {\displaystyle f:\{0,1\}^{4}\to \{0,1\}} which evaluates to 1 {\displaystyle 1} on the values 4 , 8 , 10 , 11 , 12 {\displaystyle 4,8,10,11,12} and 15 {\displaystyle 15} , evaluates to an unknown value on 9 {\displaystyle 9} and 14 {\displaystyle 14} , and to 0 {\displaystyle 0} everywhere else (where these integers are interpreted in their binary form for input to f {\displaystyle f} for succinctness of notation). The inputs that evaluate to 1 {\displaystyle 1} are called 'minterms'. We encode all of this information by writing f ( A , B , C , D ) = ∑ m ( 4 , 8 , 10 , 11 , 12 , 15 ) + d ( 9 , 14 ) . {\displaystyle f(A,B,C,D)=\sum m(4,8,10,11,12,15)+d(9,14).\,} This expression says that the output function f will be 1 for the minterms 4 , 8 , 10 , 11 , 12 {\displaystyle 4,8,10,11,12} and 15 {\displaystyle 15} (denoted by the 'm' term) and that we don't care about the output for 9 {\displaystyle 9} and 14 {\displaystyle 14} combinations (denoted by the 'd' term). The summation symbol ∑ {\displaystyle \sum } denotes the logical sum (logical OR, or disjunction) of all the terms being summed over. Step 1: finding prime implicants[edit] First, we write the function as a table (where 'x' stands for don't care): A B C D f m0 0 0 0 0 0 m1 0 0 0 1 0 m2 0 0 1 0 0 m3 0 0 1 1 0 m4 0 1 0 0 1 m5 0 1 0 1 0 m6 0 1 1 0 0 m7 0 1 1 1 0 m8 1 0 0 0 1 m9 1 0 0 1 x m10 1 0 1 0 1 m11 1 0 1 1 1 m12 1 1 0 0 1 m13 1 1 0 1 0 m14 1 1 1 0 x m15 1 1 1 1 1 One can easily form the canonical sum of products expression from this table, simply by summing the minterms (leaving out don't-care terms) where the function evaluates to one: fA,B,C,D = A'BC'D' + AB'C'D' + AB'CD' + AB'CD + ABC'D' + ABCD. which is not minimal. So to optimize, all minterms that evaluate to one are first placed in a minterm table. Don't-care terms are also added into this table (names in parentheses), so they can be combined with minterms: Number of 1s Minterm Binary Representation 1 m4 0100 m8 1000 2 (m9) 1001 m10 1010 m12 1100 3 m11 1011 (m14) 1110 4 m15 1111 At this point, one can start combining minterms with other minterms in adjacent groups. If two terms differ by only a single digit, that digit can be replaced with a dash indicating that the digit doesn't matter. Terms that can't be combined any more are marked with an asterisk (*). For instance 1000 and 1001 can be combined to give 100-, indicating that both minterms imply the first digit is 1 and the next two are 0. Number of 1s Minterm 0-Cube Size 2 Implicants 1 m4 0100 m(4,12) -100 * m8 1000 m(8,9) 100- — m(8,10) 10-0 — m(8,12) 1-00 2 m9 1001 m(9,11) 10-1 m10 1010 m(10,11) 101- — m(10,14) 1-10 m12 1100 m(12,14) 11-0 3 m11 1011 m(11,15) 1-11 m14 1110 m(14,15) 111- 4 m15 1111 — When going from Size 2 to Size 4, treat - as a third bit value. Match up the -'s first. The terms represent products and to combine two product terms they must have the same variables. One of the variables should be complemented in one term and uncomplemented in the other. The remaining variables present should agree. So to match two terms the -'s must align and all but one of the other digits must be the same. For instance, -110 and -100 can be combined to give -1-0, as can -110 and -010 to give --10, but -110 and 011- cannot since the -'s do not align. -110 corresponds to BCD' while 011- corresponds to A'BC, and BCD' + A'BC is not equivalent to a product term. Number of 1s Minterm 0-Cube Size 2 Implicants Size 4 Implicants 1 m4 0100 m(4,12) -100 * — m8 1000 m(8,9) 100- m(8,9,10,11) 10-- * — m(8,10) 10-0 m(8,10,12,14) 1--0 * — m(8,12) 1-00 — 2 m9 1001 m(9,11) 10-1 — m10 1010 m(10,11) 101- m(10,11,14,15) 1-1- * — m(10,14) 1-10 — m12 1100 m(12,14) 11-0 — 3 m11 1011 m(11,15) 1-11 — m14 1110 m(14,15) 111- — 4 m15 1111 — — Note: In this example, none of the terms in the size 4 implicants table can be combined any further. In general this process should be continued (sizes 8, 16 etc.) until no more terms can be combined. Step 2: prime implicant chart[edit] None of the terms can be combined any further than this, so at this point we construct an essential prime implicant table. Along the side goes the prime implicants that have just been generated (these are the ones that have been marked with a "*" in the previous step), and along the top go the minterms specified earlier. The don't care terms are not placed on top—they are omitted from this section because they are not necessary inputs. 4 8 10 11 12 15 ⇒ A B C D m(4,12) # ⇒ — 1 0 0 m(8,9,10,11) ⇒ 1 0 — — m(8,10,12,14) ⇒ 1 — — 0 m(10,11,14,15) # ⇒ 1 — 1 — To find the essential prime implicants, we look for columns with only one "✓". If a column has only one "✓", this means that the minterm can only be covered by one prime implicant. This prime implicant is essential. For example: in the first column, with minterm 4, there is only one "✓". This means that m(4,12) is essential (hence marked by #). Minterm 15 also has only one "✓", so m(10,11,14,15) is also essential. Now all columns with one "✓" are covered. The rows with minterm m(4,12) and m(10,11,14,15) can now be removed, together with all the columns they cover. The second prime implicant can be 'covered' by the third and fourth, and the third prime implicant can be 'covered' by the second and first, and neither is thus essential. If a prime implicant is essential then, as would be expected, it is necessary to include it in the minimized boolean equation. In some cases, the essential prime implicants do not cover all minterms, in which case additional procedures for chart reduction can be employed. The simplest "additional procedure" is trial and error, but a more systematic way is Petrick's method. In the current example, the essential prime implicants do not handle all of the minterms, so, in this case, the essential implicants can be combined with one of the two non-essential ones to yield one equation: fA,B,C,D = BC'D' + AB' + AC[30] or fA,B,C,D = BC'D' + AD' + AC Both of those final equations are functionally equivalent to the original, verbose equation: fA,B,C,D = A'BC'D' + AB'C'D' + AB'C'D + AB'CD' + AB'CD + ABC'D' + ABCD' + ABCD. See also[edit] Blake canonical form Buchberger's algorithm – analogous algorithm for algebraic geometry Petrick's method Qualitative comparative analysis (QCA) References[edit] ^ Quine, Willard Van Orman (October 1952). "The Problem of Simplifying Truth Functions". The American Mathematical Monthly. 59 (8): 521–531. doi:10.2307/2308219. JSTOR 2308219. ^ Quine, Willard Van Orman (November 1955). "A Way to Simplify Truth Functions". The American Mathematical Monthly. 62 (9): 627–631. doi:10.2307/2307285. hdl:10338.dmlcz/142789. JSTOR 2307285. ^ McCluskey, Edward Joseph Jr. (November 1956). "Minimization of Boolean Functions". Bell System Technical Journal. 35 (6): 1417–1444. doi:10.1002/j.1538-7305.1956.tb03835.x. hdl:10338.dmlcz/102933. Retrieved 2014-08-24. ^ McColl, Hugh (1878-11-14). "The Calculus of Equivalent Statements (Third Paper)". Proceedings of the London Mathematical Society. s1-10 (1): 16–28. doi:10.1112/plms/s1-10.1.16. ^ Ladd, Christine (1883). "On the algebra of logic". In Peirce, Charles Sanders (ed.). Studies in Logic. Bos contentType 24 text/html; charset=UTF-8 url 67 https://en.wikipedia.org:443/wiki/Quine%E2%80%93McCluskey_algorithm responseCode 3 200 